## 小知识总结
### small point
1. try catch 可以使得异常被捕获，防止应用崩溃；
2. 数据的实时上报会频繁请求网络链接，影响性能，可以存储到数据库，也可以把多条数据拼接到一起然后上报，也可以延迟上报即等到数据达到一定数量或者延迟一定时间后再统一上报。
3. 在设计程序的时候，注意不要增加cpu负载，影响性能。尽量减少内存的使用率。
4. static静态代码块是在类加载的时候会被直接加载到内存中，调用时效率速度块。static静态变量会受多线程影响，可能不安全。
5. 字符串拼接的时候，注释写好拼接的思路。字符串处理（substring，split）虽然耗时，但是只要不是很长的字符串或者频繁多次的进行字符串操作，效率影响不高。
6. 局部变量注意命名意义
7. app工程build.gradle配置文件，工程build文件，application的build文件，module（lib）的build文件。首先执行工程的build.gradle文件，然后才去执行其他的配置文件。所以当apply插件的时候，应该在工程的build.gradle中用classpath引入插件。
8. runnable不是线程，可以理解为一个可执行的对象，可执行run方法。只有thread才是一个线程对象
9. aop动态插入代码会导致堆栈中获取的方法改变，aop插入会在编译期间改变代码和方法，进而使得获取的堆栈中方法不是自己代码定义的方法，增加分析难度。
10. 内存泄露是指app（应用）在一次启动后，在本进程中，内存中有对象不能被回收，造成泄露。从而使得，造成内存不断的累计
，发生OOM。注意：杀死本次应用进程后这些泄露的内存就能被回收。也就是说如果对象在一次启动中只会产生一次，即使泄露，也不会造成OOM，前提是这个对象不会重复产生。
11. 在配置maven上传，有一个步骤是在etc/maven下的setting文件，在里面配置用户名和密码
12. 高频率重复创建对象，会增加内存负担，引发内存抖动，（可以通过高频率重复可疑创建对象的操作，monitor监视内存是否有很多尖峰），触发频繁的gc操作。gc操作时所有线程都会被暂停，频繁gc引发卡顿。可以使用静态内部类重复使用，内存池、缓存池的方式
13. 链接13中的问题，使用静态内部对象（静态内部类），静态内部类是全局的，每次开始使用的静态对象时必须先clear一下清楚数据，然后重复使用，达到减少对象重复创建目的。
14. 用户态到核心态，IO会导致从用户态到核心态，切换是耗时操作
15. 虚拟机davlick内存状态，pss、privateDirty、shareDirty。heap（堆）+ 静态常量
16. map执行clear之后map变量仍然占内存，但是里面数据为空
17. 子线程中的抛出的异常依然会导致应用的崩溃。比如子线程中抛出空指针异常，此时会导致应用崩溃而仅仅是该子线程死亡
18. Map<Thread, StackTraceElement[]> map = Thread.getAllStackTraces();StackTraceElement代表堆栈中的一行数据，StackTraceElement[]代表能够看到的一个完整的堆栈。map中的一个key－value键值对代表某一个thread中当前采样的完整堆栈StackTraceElement[]
19. 守护进程的意义
20. mHandler.removeCallbacksAndMessage(null)在用handler的时候最后要移除所有message


### big point
**new 一个对象的时候JVM都做了哪些事情：**
1. 之前没有进行类加载，类加载，同时初始化类中静态的属性（赋默认值）
2. 执行静态代码块
3. 分配内存空间，同时初始化非静态的属性（赋默认值）
4. 调用父类构造器
5. 父类构造器执行完后，如果自己声明属性的同时有显示的赋值，那么进行显示赋值把默认值覆盖
6. 执行匿名代码块
7. 执行构造器
8. 返回内存地址
